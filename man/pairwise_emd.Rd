% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/analysis.R
\name{pairwise_emd}
\alias{pairwise_emd}
\title{Compute Pairwise EMD Over a List of Matrices}
\usage{
pairwise_emd(tsne_matrices, downsample_rows = 1000, comparison_runs = 10,
  summary_funs = list(mean = mean, variance = var),
  parallel_cores = parallel::detectCores(), verbose_timing = FALSE)
}
\arguments{
\item{tsne_matrices}{named list of matrices, each with the same number of
columns. Need not have the same number of rows, but should be nonempty.}

\item{downsample_rows}{positive integer, the number of rows to downsample
each matrix to on each EMD comparison. If this is greater than the number
of rows in the matrix with fewest rows in \code{tsne_matrices}, it will be
shrunk to the number of rows of the smallest matrix.}

\item{comparison_runs}{positive integer, the number of times to perform the
EMD computation for each pair of matrices in \code{tsne_matrices}.}

\item{summary_funs}{list of functions, each of which accept a floating-point
vector and produce a scalar floating-point. Names will be reused in the
output if provided.}

\item{parallel_cores}{positive integer, number of cores to use for
parallelism. Default should be optimal.}

\item{verbose_timing}{logical, whether to display a message describing the
runtime at the conclusion of each EMD calculation.}
}
\value{
Named list of symmetric distance matrices containing the result of
applying each of \code{summary_funs} to each vector of \code{comparison_runs} EMD
calculations for each pair of matrices in the input. Each matrix's row
and column names are set to the names of \code{tsne_matrices}.\preformatted{The output list also contains the keys `downsample_rows` and
`comparison_runs` (in that order, at the start of the output list),
containing the values provided to these arguments when this function was
called. If names are provided to elements of `summary_funs`, they are
reused for the corresponding element of the output list.
}
}
\description{
\code{pairwise_emd} computes the Earth Mover's Distance (EMD)
between the rows of each pair of matrices given, and writes the
resultant distance matrix to a CSV file.
}
\details{
For each pair of matrices in \code{tsne_matrices}, a floating-point
vector is generated by downsampling both matrices to
\code{downsample_rows} and performing the EMD calculation on the downsampled
matrices with \code{\link[transport:wasserstein]{transport::wasserstein()}}. This is performed
\code{comparison_runs} times per pair of matrices, producing a vector of
length \code{comparison_runs}.\preformatted{Each function in `summary_funs` is applied to each vector of EMD
calculations, producing a list of symmetrical distance matrices. In other
words, each of the matrices in this list is produced by applying the
corresponding function in `summary_funs` to the vector of EMD
calculations for each pair of elements in `tsne_matrices`. If names are
provided to elements of `summary_funs`, they are reused for the
corresponding element of the output list.

For example, if `summary_funs = list(mean = mean)`, the output list
contains an n x n matrix of the mean of each EMD run for each pair of
matrices in `tsne_matrices` (where `n == length(tsne_matrices)`).
}
}
\examples{
## create example matrices (need not have same number of rows)
a <- matrix(runif(100, 0, 1), ncol = 2)
b <- matrix(runif(100, 0, 1), ncol = 2)
c <- matrix(runif(100, 0, 1), ncol = 2)
## calc pairwise EMD 15 times and get mean, median, and sample variance of
## the 15 calculations per pair, downsampling to 45 rows each time
result <- pairwise_emd(
    list("matrix A" = a,
         "matrix B" = b,
         "matrix C" = c),
    downsample_rows = 45,
    comparison_runs = 15,
    summary_funs = list("mean" = mean,
                        "median" = median,
                        "variance" = var))
## the downsampling size/sample runs specified are also in the output;
## also observe that the distance matrices are symmetric along the diagonal
## from the lower-left to upper-right
result
## $downsample_rows
## [1] 45
##
## $comparison_runs
## [1] 15
##
## $mean
##           matrix C  matrix B  matrix A
## matrix A 0.1342866 0.1524013 0.0000000
## matrix B 0.1094125 0.0000000 0.1524013
## matrix C 0.0000000 0.1094125 0.1342866
##
## $median
##           matrix C  matrix B  matrix A
## matrix A 0.1351538 0.1556969 0.0000000
## matrix B 0.1101228 0.0000000 0.1556969
## matrix C 0.0000000 0.1101228 0.1351538
##
## $variance
##              matrix C     matrix B     matrix A
## matrix A 0.0001382563 0.0001742527 0.0000000000
## matrix B 0.0000721925 0.0000000000 0.0001742527
## matrix C 0.0000000000 0.0000721925 0.0001382563
## plot a heatmap of the mean EMD
gplots::heatmap.2(result$mean, cexRow = 1, cexCol = 1)
## (R graphics window)

}
\seealso{
\code{\link[transport:wasserstein]{transport::wasserstein()}} for the underlying EMD
implementation. \code{\link[gplots:heatmap.2]{gplots::heatmap.2()}} can be used to plot heatmaps of the
distance matrices computed.
}
