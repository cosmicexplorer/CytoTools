#' @import magrittr
#' @import dplyr


### Clean fcs data.

## TODO: get alternatives and comparisons to this
#' @title Hyperbolic Arcsin Transform for Cytometry Data
#'
#' @description `asinh_transform` generates a *function* which applies the
#'     hyperbolic transformation with the specified `cofactor`.
#'
#' @param cofactor numeric, divide the input by this number before applying
#'     [asinh()].
#'
#' @return A vectorized *function* accepting one argument `x`, which applies
#'     `asinh(x / cofactor)`.
#'
#' @references Garner, Duane L., et al. "Fluorometric assessments of
#'     mitochondrial function and viability in cryopreserved bovine
#'     spermatozoa." Biology of Reproduction 57.6 (1997): 1401-1406.
#'
#' @seealso The [asinh()] function is used to perform the arcsin transformation.
#'
#' @examples
#' ## create a transformation function
#' arcsin_trans_five <- asinh_transform(5)
#' ## this returns a function!
#' ## function (x) { asinh(x / cofactor) }
#' ## <environment: 0xf6e0da8>
#'
#' ## create some example inputs
#' v <- c(4, 3.2)
#' ## [1] 4.0 3.2
#' m <- matrix((1:4)^1.5, nrow = 2)
#' ##          [,1]     [,2]
#' ## [1,] 1.000000 5.196152
#' ## [2,] 2.828427 8.000000
#'
#' ## use the transformation on your data
#' arcsin_trans_five(v)
#' ## [1] 0.7326683 0.6028207
#' arcsin_trans_five(m)
#' ##           [,1]      [,2]
#' ## [1,] 0.1986901 0.9088435
#' ## [2,] 0.5391786 1.2489833
#'
#' @export
#'
asinh_transform <- function (cofactor) { function (x) {
    asinh(x / cofactor)
}}

normalize_channels <- function (s) {
    s %>% toupper %>% gsub("[[:punct:][:space:]]", "", ., perl = TRUE)
}

paste_string_array <- function (strings, collapse = ", ", fmt = "[%s]") {
    paste0("\"", strings, "\"", collapse = collapse) %>% sprintf(fmt, .)
}

#' @title Extract and Transform Phenotype Channels from a CyToF Dataset
#'
#' @description `normalize_pheno_channels_dataset` matches a set of canonical
#'     channel names containing phenotype data over a list of populations and
#'     reference population, and applies a specified transformation to the
#'     phenotype channels.
#'
#' @param pheno_channel_names character vector without duplicates containing
#'     names of channels to extract from each population. See details for how it
#'     is interpreted.
#' @param pop_list named list of data frames containing CyToF data, e.g. from
#'     [read_files_sorted()]. `names(pop_list)` must be unique and **NOT**
#'     contain the name `"REF"`. This is intentional.
#' @param ref a data frame containing CyToF data, as from [read_cyto_file()], or
#'     NULL. If NULL, the populations in `pop_list` are joined with [rbind()]
#'     after their channel names are converted to `pheno_channel_names`.
#' @param transform_fun vectorized function to transform the raw channel values,
#'     such as generated by [asinh_transform()].
#'
#' @details Attempts to find the column name in each population of `pop_list`
#'     and `ref` corresponding to each element of `pheno_channel_names`. If an
#'     element of `pheno_channel_names` appears *exactly* in a column name, it
#'     is used. If multiple column names match a desired channel name, or none
#'     match, the function logs that and throws an error at the end with all of
#'     these errors.
#'
#' @return named list with keys `pop_list` and `ref`.
#'
#'     The key `pop_list` contains the list of data frames from the argument
#'     `pop_list` after extracting `pheno_channel_names`. The [names()] of the
#'     argument `pop_list` are reused.
#'
#'     The key `ref` contains a data frame with either the reference population
#'     given by the argument `ref` (with the columns matched by
#'     `pheno_channel_names` extracted), or all the events in `pop_list` joined
#'     together with [rbind()] after extracting `pheno_channel_names`.
#'
#' @seealso [read_files_sorted()] and [read_cyto_file()] to use as inputs to
#'     `pop_list` and `ref`, and [asinh_transform()] to use as a transformation
#'     on the raw channel values.
#'
#' @examples
#' ## make some example data (values are not representative of real data)
#' a <- data.frame(CCR5 = rnorm(5, 0, 5), "CD3-144" = rnorm(5, 0, 5),
#'                 check.names = FALSE)
#' b <- data.frame(CCR5 = rnorm(10, 0, 5), "CD3-119" = rnorm(10, 0, 5),
#'                 check.names = FALSE)
#' cd <- data.frame("CCR-5" = rnorm(12, 0, 5), CD3 = rnorm(12, 0, 5),
#'                 CD33 = rnorm(12, 0, 5), check.names = FALSE)
#' ## example reference
#' ref <- data.frame(CCR5 = rnorm(3, 0, 5), CD3 = rnorm(3, 0, 5))
#'
#' ## invocation -- note that asinh_transform(5) is a FUNCTION
#' ## the string "CD3" was matched exactly in channels "CD3-144" and "CD3-119",
#' ## so it detects them correctly
#' normalize_pheno_channels_dataset(
#'     c("CCR5", "CD3"), list("pop A" = a, "pop B" = b), ref = ref,
#'     transform_fun = asinh_transform(5))
#' ## $pop_list
#' ## $pop_list[[1]]
#' ##            CCR5         CD3
#' ## [1,] -1.3571036  0.44244228
#' ## [2,]  0.4194871 -0.39560702
#' ## [3,] -1.3835876 -0.03439362
#' ## [4,] -0.8761360 -0.72185809
#' ## [5,]  0.2314494 -0.84833769
#' ##
#' ## $pop_list[[2]]
#' ##              CCR5        CD3
#' ##  [1,]  0.27778580 -0.1087184
#' ##  [2,]  0.20259186  0.4651526
#' ##  [3,] -1.73009568 -0.1646274
#' ##  [4,]  0.40905722  0.7566038
#' ##  [5,] -0.58926777 -0.8594370
#' ##  [6,]  0.24980969 -0.6503514
#' ##  [7,]  0.78063390  1.0762774
#' ##  [8,] -0.20117061  0.2963788
#' ##  [9,] -0.62969008  0.3292135
#' ## [10,]  0.05312882  0.3456103
#' ##
#' ##
#' ## $ref
#' ##            CCR5        CD3
#' ## [1,] -0.2221288  0.6901822
#' ## [2,] -1.0284534 -1.2788120
#' ## [3,] -0.1501430  0.2978884
#' ##
#'
#' ## "CCR5" does NOT show up exactly in pop C, so it throws an error, but tries
#' ## to find similarly-named columns
#' normalize_pheno_channels_dataset(
#'     c("CCR5", "CD3"), list("pop A" = a, "pop B" = b, "pop C" = cd),
#'     ref = ref)
#' ## no match for channel 'CCR5' in population 'pop C'; while this is pure
#' ## guesswork, some possibilities *might* be: ["CCR-5"]
#' ## more than one match was found for channel 'CD3' in population 'pop C'
#' ## (this may indicate a bug): ["CD3", "CD33"]
#' ## Error in normalize_pheno_channels_dataset(c("CCR5", "CD3"), list(`pop A` :
#' ##   errors found during normalization
#'
#' ## in the previous example, multiple channels match "CD3" exactly, which also
#' ## causes an error (we don't want to accidentally use a "CD33" channel).
#' ## add some more fake data and now tell it to use the "CD33" channel as well,
#' ## and it is now smart enough to know not to misuse the "CD33" channel
#' a[,"CD33"] <- rnorm(5, 0, 5)
#' b[,"CD33"] <- rnorm(10, 0, 5)
#' cd[,"CCR5"] <- cd[,"CCR-5"]
#' ref[,"CD33-114"] <- rnorm(3, 0, 5)
#' normalize_pheno_channels_dataset(
#'     c("CCR5", "CD3", "CD33"),
#'     list("pop A" = a, "pop B" = b, "pop C" = cd), ref = ref)
#' ## $pop_list
#' ## $pop_list[[1]]
#' ##            CCR5        CD3       CD33
#' ## [1,] -0.9512973 -0.6753894  1.7032997
#' ## [2,]  0.4382074 -0.0999171 -0.7765234
#' ## [3,]  1.2189722 -1.0124230 -0.5081921
#' ## [4,] -0.3854615 -1.2393886  0.4282537
#' ## [5,]  0.2665361 -0.6581783 -1.1698828
#' ##
#' ## $pop_list[[2]]
#' ##              CCR5        CD3         CD33
#' ##  [1,] -0.41623276 -1.2707792 -0.097147561
#' ##  [2,] -0.06911852 -1.8176153 -0.632693022
#' ##  [3,]  0.25930404  0.1235879  0.475103994
#' ##  [4,] -1.09454929  1.2005497 -1.208523332
#' ##  [5,] -0.93752579 -0.9420507  1.358430135
#' ##  [6,] -0.62597474  0.3766091 -0.393847648
#' ##  [7,]  0.61259614 -0.1355130 -0.008940949
#' ##  [8,]  1.01004676 -0.2293936  0.552282662
#' ##  [9,]  0.49647024 -0.3595328 -0.389304614
#' ## [10,]  1.17525574  1.0785971  0.010015518
#' ##
#' ## $pop_list[[3]]
#' ##              CCR5        CD3        CD33
#' ##  [1,] -0.77140821  0.4511830  0.92498386
#' ##  [2,] -0.92331783  0.7450197 -0.58156055
#' ##  [3,] -0.86837711 -0.5238199 -0.46144758
#' ##  [4,]  1.08657936  0.5653928 -0.03154463
#' ##  [5,]  1.19430952 -0.9029035 -1.37456983
#' ##  [6,]  1.43774755  0.3475482  0.70819858
#' ##  [7,]  1.07056107 -0.5853111 -0.05238444
#' ##  [8,]  0.03620114 -0.6124719  0.32051220
#' ##  [9,] -0.46804991 -1.3971870  0.78790251
#' ## [10,] -0.13056437 -0.9643665  0.22749253
#' ## [11,]  1.58686668  0.6491622 -0.11065898
#' ## [12,]  0.76899275 -0.5669664  0.87053700
#' ##
#' ##
#' ## $ref
#' ##            CCR5        CD3      CD33
#' ## [1,] -0.1405579  0.6416779 0.7893279
#' ## [2,] -0.5616811 -1.3688846 1.2802796
#' ## [3,]  0.5900767 -1.6768527 0.5947007
#' ##
#'
#' @export
#'
normalize_pheno_channels_dataset <- function
(
    pheno_channel_names, pop_list, ref,
    transform_fun = asinh_transform(5)
) {
    stopifnot(is.vector(pheno_channel_names, 'character'),
              is.list(pop_list),
              lapply(pop_list, is.data.frame) %>% unlist,
              is.data.frame(ref),
              is.function(transform_fun),
              anyDuplicated(pheno_channel_names) == 0)
    stopifnot(!is.null(names(pop_list)))
    if (anyDuplicated(names(pop_list)) != 0) {
        stop(sprintf("names of pop_list must be unique: %s",
                     paste_string_array(names(pop_list))))
    }
    if ("REF" %in% names(pop_list)) {
        stop(sprintf(paste(
            "REF is in the names of pop_list, but it is reserved",
            "for the reference population: %s"),
            paste_string_array(names(pop_list))))
    }
    pop_ref_list <- c(list(REF = ref), pop_list)
    ## we're matching channel names by fixed strings, and throw if there are
    ## multiple matches for a channel name. if one channel name is a substring
    ## of another (e.g. CD45RA and CD45), and we search for CD45 first, we'll
    ## find results for both
    super_first <- pheno_channel_names %>% as.list %>%
        comparisort::merge_sort(function (a, b) grepl(b, a, fixed = TRUE)) %>%
        unlist
    errors <- list()
    pops_right_channels <- lapply(1:length(pop_ref_list), function (pop_idx) {
        pop <- pop_ref_list[[pop_idx]]
        ret <- cbind(pop)
        desc <- names(pop_ref_list)[[pop_idx]]
        for (chan in super_first) {
            channels <- rep(colnames(pop))
            matched <- grep(chan, channels, fixed = TRUE)
            if (length(matched) == 0) {
                dists <- channels %>% normalize_channels %>%
                    adist(normalize_channels(chan),
                          costs = c(i = 1, d = 0.01, s = 0.5)) %>%
                    as.vector
                maybe_similar <- channels[dists < 0.5]
                if (length(maybe_similar) == 0) {
                    errors <<- c(errors, list(sprintf(paste(
                        "no match for channel '%s' in population '%s',",
                        "and this program is not smart enough to know why",
                        "('%s' may just not exist in population '%s')"),
                        chan, desc, chan, desc)))
                } else {
                    errors <<- c(errors, list(sprintf(paste(
                        "no match for channel '%s' in population '%s';",
                        "while this is pure guesswork,",
                        "some possibilities *might* be: %s"),
                        chan, desc, paste_string_array(maybe_similar))))
                }
            } else if (length(matched) > 1) {
                errors <<- c(errors, list(sprintf(paste(
                    "more than one match was found for channel '%s'",
                    "in population '%s' (this may indicate a bug): %s"),
                    chan, desc, paste_string_array(channels[matched]))))
            } else {
                ret[,chan] <- pop[,channels[matched]]
                pop <- pop[,channels[-matched], drop = FALSE]
            }
        }
        ret
    })
    if (length(errors) > 0) {
        for (err in errors) {
            msg("%s", err)
        }
        stop("errors found during normalization")
    }
    final_pops <- pops_right_channels %>% lapply(function (pop) {
        pop[,pheno_channel_names] %>% as.matrix %>% transform_fun
    })
    list(pop_list = final_pops[-1],
         ref = final_pops[[1]])
}


### Analyze populations in a dataset.

compute_pairwise_emd_trials <- function (matrices, clust,
                                         downsample_rows, comparison_runs,
                                         verbose_timing) {
    n <- length(matrices)
    msg("starting pairwise emd on %s populations...", n)
    lapply(1:n, function (i) {
        final_col <- as.integer(n - i)
        msg("computing row %s/%s, requiring column(s) %s:%s",
            i, n, 1, final_col)
        i_mat <- matrices[[i]]
        cols <- safe_int_seq(1L, final_col)
        parallel::parLapply(clust, cols, function (j) {
            this_pid <- Sys.getpid()
            j_mat <- matrices[[n - j + 1]]
            lapply(1:comparison_runs, function (r) {
                i_wpp <- sample(1:nrow(i_mat), downsample_rows) %>%
                    i_mat[.,] %>% transport::wpp(rep(1, downsample_rows))
                j_wpp <- sample(1:nrow(j_mat), downsample_rows) %>%
                    j_mat[.,] %>% transport::wpp(rep(1, downsample_rows))
                single_entry <- CytoTools::timed_execute(transport::wasserstein(
                    i_wpp, j_wpp, control = transport::trcontrol(
                        a = i_wpp, b = j_wpp, method = "shortsimplex")),
                    ## weird that this is necessary when using timed_execute
                    ## inside a worker
                    env = environment())
                if (verbose_timing) {
                    message(sprintf(paste(
                        "run %s/%s for row %s/%s, column %s/%s",
                        "on worker %s took %s sec"),
                        r, comparison_runs, i, n, j, length(cols),
                        this_pid, single_entry$time))
                }
                single_entry$value
            }) %>% unlist
        })
    })
}

summarize_computed_trials <- function (fun, trials, nm) {
    stopifnot(is.function(fun))
    n <- length(trials)
    result <- matrix(double(n * n), n, n, dimnames = list(nm, rev(nm)))
    for (i in 1:n) {
        next_cols <- result[rev(safe_int_seq(1L, as.integer(i - 1))),
                            (n - i + 1)]
        result[i,] <- lapply(trials[[i]], fun) %>% unlist %>% c(0, next_cols)
    }
    result
}


#' @title Compute Pairwise EMD Over a List of Matrices
#'
#' @description `pairwise_emd` computes the Earth Mover's Distance (EMD)
#'     between the rows of each pair of matrices given, and writes the
#'     resultant distance matrix to a CSV file.
#'
#' @param tsne_matrices named list of matrices, each with the same number of
#'     columns. Need not have the same number of rows, but should be nonempty.
#' @param downsample_rows positive integer, the number of rows to downsample
#'     each matrix to on each EMD comparison. If this is greater than the number
#'     of rows in the matrix with fewest rows in `tsne_matrices`, it will be
#'     shrunk to the number of rows of the smallest matrix.
#' @param comparison_runs positive integer, the number of times to perform the
#'     EMD computation for each pair of matrices in `tsne_matrices`.
#' @param summary_funs list of functions, each of which accept a floating-point
#'     vector and produce a scalar floating-point. Names will be reused in the
#'     output if provided.
#' @param parallel_cores positive integer, number of cores to use for
#'     parallelism. Default should be optimal.
#' @param verbose_timing logical, whether to display a message describing the
#'     runtime at the conclusion of each EMD calculation.
#'
#' @return Named list of symmetric distance matrices containing the result of
#'     applying each of `summary_funs` to each vector of `comparison_runs` EMD
#'     calculations for each pair of matrices in the input. Each matrix's row
#'     and column names are set to the names of `tsne_matrices`.
#'
#'     The output list also contains the keys `downsample_rows` and
#'     `comparison_runs` (in that order, at the start of the output list),
#'     containing the values provided to these arguments when this function was
#'     called. If names are provided to elements of `summary_funs`, they are
#'     reused for the corresponding element of the output list.
#'
#' @details For each pair of matrices in `tsne_matrices`, a floating-point
#'     vector is generated by downsampling both matrices to
#'     `downsample_rows` and performing the EMD calculation on the downsampled
#'     matrices with [transport::wasserstein()]. This is performed
#'     `comparison_runs` times per pair of matrices, producing a vector of
#'     length `comparison_runs`.
#'
#'     Each function in `summary_funs` is applied to each vector of EMD
#'     calculations, producing a list of symmetrical distance matrices. In other
#'     words, each of the matrices in this list is produced by applying the
#'     corresponding function in `summary_funs` to the vector of EMD
#'     calculations for each pair of elements in `tsne_matrices`. If names are
#'     provided to elements of `summary_funs`, they are reused for the
#'     corresponding element of the output list.
#'
#'     For example, if `summary_funs = list(mean = mean)`, the output list
#'     contains an n x n matrix of the mean of each EMD run for each pair of
#'     matrices in `tsne_matrices` (where `n == length(tsne_matrices)`).
#'
#' @seealso [transport::wasserstein()] for the underlying EMD
#'     implementation. [gplots::heatmap.2()] can be used to plot heatmaps of the
#'     distance matrices computed.
#'
#' @examples
#' ## create example matrices (need not have same number of rows)
#' a <- matrix(runif(100, 0, 1), ncol = 2)
#' b <- matrix(runif(100, 0, 1), ncol = 2)
#' c <- matrix(runif(100, 0, 1), ncol = 2)
#' ## calc pairwise EMD 15 times and get mean, median, and sample variance of
#' ## the 15 calculations per pair, downsampling to 45 rows each time
#' result <- pairwise_emd(
#'     list("matrix A" = a,
#'          "matrix B" = b,
#'          "matrix C" = c),
#'     downsample_rows = 45,
#'     comparison_runs = 15,
#'     summary_funs = list("mean" = mean,
#'                         "median" = median,
#'                         "variance" = var))
#' ## the downsampling size/sample runs specified are also in the output;
#' ## also observe that the distance matrices are symmetric along the diagonal
#' ## from the lower-left to upper-right
#' result
#' ## $downsample_rows
#' ## [1] 45
#' ##
#' ## $comparison_runs
#' ## [1] 15
#' ##
#' ## $mean
#' ##           matrix C  matrix B  matrix A
#' ## matrix A 0.1342866 0.1524013 0.0000000
#' ## matrix B 0.1094125 0.0000000 0.1524013
#' ## matrix C 0.0000000 0.1094125 0.1342866
#' ##
#' ## $median
#' ##           matrix C  matrix B  matrix A
#' ## matrix A 0.1351538 0.1556969 0.0000000
#' ## matrix B 0.1101228 0.0000000 0.1556969
#' ## matrix C 0.0000000 0.1101228 0.1351538
#' ##
#' ## $variance
#' ##              matrix C     matrix B     matrix A
#' ## matrix A 0.0001382563 0.0001742527 0.0000000000
#' ## matrix B 0.0000721925 0.0000000000 0.0001742527
#' ## matrix C 0.0000000000 0.0000721925 0.0001382563
#' ## plot a heatmap of the mean EMD
#' gplots::heatmap.2(result$mean, cexRow = 1, cexCol = 1)
#' ## (R graphics window)
#'
#' @export
#'
pairwise_emd <- function
(
    tsne_matrices,
    downsample_rows = 1000,
    comparison_runs = 10,
    summary_funs = list(mean = mean, variance = var),
    parallel_cores = parallel::detectCores(),
    verbose_timing = FALSE
) {
    downsample_rows <- tsne_matrices %>% lapply(nrow) %>% unlist %>%
        min(downsample_rows) %>% as.integer
    comparison_runs <- as.integer(comparison_runs)
    stopifnot(is_counting_num(downsample_rows),
              is_counting_num(comparison_runs),
              is_counting_num(parallel_cores))
    nm <- get_names(tsne_matrices)
    ## NOTE: outfile = "" goes to console, EXCEPT in Rgui on Windows!
    clust <- parallel::makeCluster(parallel_cores, outfile = "")
    computed_trials <- tryCatch(
        finally = parallel::stopCluster(clust),
        compute_pairwise_emd_trials(
            tsne_matrices, clust, downsample_rows, comparison_runs,
            verbose_timing))
    c(list(downsample_rows = downsample_rows,
           comparison_runs = comparison_runs),
      lapply(summary_funs, (. %>% summarize_computed_trials(
          computed_trials, nm))))
}

normal_iqr <- function (x, ...) {
    IQR(x, type = 2, ...)
}

#' @title Compute MEM Scores Over Populations in a Dataset
#'
#' @description `calc_mem` computes the Marker Enrichment Modelling (MEM) score
#'     of each population given against the provided reference population.
#'
#' @param pop_list list of floating-point matrices or data frames, each with the
#'     same column names in the same order. Each column represents *transformed*
#'     expression levels of the named phenotype.
#' @param ref floating-point matrix or data frame with the same column names in
#'     the same order as each element of `pop_list`, with entries representing
#'     *transformed* expression levels. Used as reference population.
#' @param IQRthresh positive scalar floating-point, used as lower bound for IQR
#'     calculations (see MEM paper).
#' @param scale_limit positive scalar floating-point or `NULL`. If not `NULL`,
#'     MEM values are scaled so the greatest maximum absolute MEM value is equal
#'     to `scale_limit`, otherwise no scaling occurs.
#'
#' @return matrix with column names as in `pop_list` and `ref`, row names equal
#'     to the names of `pop_list` (if given). Each row contains the MEM values
#'     of a population in `pop_list` for each phenotype channel, in the same
#'     order as given.
#'
#' @details Note that the values of entries in `ref` and the populations of
#'     `pop_list` are assumed to already be transformed (typically an arcsinh
#'     transform, as in [asinh_transform()]).
#'
#'     To obtain a distance matrix of the Root Mean Square Distance (RMSD)
#'     betwen each population's MEM scores, the [dist()] function can be used,
#'     and converted to a matrix with [as.matrix()].
#'
#' @seealso [normalize_pheno_channels_dataset()] can be used to generate
#'     a suitable `pop_list` and `ref` from a CyToF dataset, applying
#'     transformations and normalizing phenotype channel names.
#'
#' @references Diggins, Kirsten E., et al. "Characterizing cell subsets using
#'     marker enrichment modeling." Nature Methods 14.3 (2017): 275-278.
#'
#' @examples
#' ## make some example data (values are not representative of real data)
#' ## inputs to `calc_mem` should be transformed already (e.g. the below
#' ## could represent an arcsinh-transformed dataset)
#' a <- data.frame(CCR5 = rnorm(100, 0, 5), CD3 = rnorm(100, 0, 5))
#' b <- data.frame(CCR5 = rnorm(150, 0, 5), CD3 = rnorm(150, 0, 5))
#' c <- data.frame(CCR5 = rnorm(150, 0, 5), CD3 = rnorm(150, 0, 5))
#' ## example reference
#' ref <- data.frame(CCR5 = rnorm(300, 0, 5), CD3 = rnorm(300, 0, 5))
#'
#' ## calculate MEM with minimum IQR of 0.5, scaled so maximum absolute
#' ## magnitude is equal to 10 (as suggested in MEM paper)
#' mems <- calc_mem(list("pop A" = a, "pop B" = b),
#'          ref,
#'          IQRthresh = 0.5, scale_limit = 10)
#' mems
#' ##            CCR5       CD3
#' ## pop A -2.446713 -1.085913
#' ## pop B -1.304841 -1.620452
#' ## pop C  3.201968 10.000000
#'
#' ## make a distance matrix of the RMSD between populations
#' as.matrix(dist(mems))
#' ##           pop A     pop B    pop C
#' ## pop A  0.000000  1.260795 12.44207
#' ## pop B  1.260795  0.000000 12.46380
#' ## pop C 12.442068 12.463797  0.00000
#'
#' @export
#'
calc_mem <- function (pop_list, ref,
                      IQRthresh = 0.5,
                      scale_limit = NULL) {
    markers <- colnames(ref)
    for (pop in pop_list) {
        stopifnot(compare_names(colnames(pop), markers))
    }
    pop_names <- names(pop_list)
    ## make data frames of pop median/iqr
    mag_pops <- pop_list %>%
        lapply((. %>% apply(2, median))) %>%
        Reduce(f = cbind) %>%
        t %>% set_rownames(pop_names)
    iqr_pops <- pop_list %>%
        lapply((. %>% apply(2, normal_iqr))) %>%
        Reduce(f = cbind) %>%
        t %>% set_rownames(pop_names)
    ## vectors for ref stats
    MAGref <- ref %>% apply(2, median) %>% t
    IQRref <- ref %>% apply(2, normal_iqr) %>% t
    ## FIXME: current MEM function takes abs of MAGpop and MAGref (WHY???)
    mag_diffs <- mag_pops %>%
        apply(1, function (MAGpop) abs(MAGpop) - abs(MAGref)) %>%
        t %>% set_colnames(markers)
    ## FIXME: current MEM function thresholds IQRref as well (WHY???)
    stopifnot(is_nonneg_scalar(IQRthresh, allow_zero = FALSE))
    iqr_ratios_with_threshold <- pmax(iqr_pops, IQRthresh) %>%
        apply(1, function (IQRpop) pmax(IQRref, IQRthresh) / IQRpop) %>%
        t %>% set_colnames(markers)
    ## this is the MEM formula -- see reference
    mems <- (abs(mag_diffs) + iqr_ratios_with_threshold - 1) * sign(mag_diffs)
    ## dilate so the greatest MEM value has magnitude equal to scale_limit
    if (is.null(scale_limit)) {
        mems
    } else {
        stopifnot(is_nonneg_scalar(scale_limit, allow_zero = FALSE))
        max_mem <- mems %>% abs %>% max
        mems / max_mem * scale_limit
    }
}


#' @title Plot Pairwise Comparisons of Cytometry Datasets
#'
#' @description `plot_pairwise_comparison` plots a heatmap of a pairwise
#'     comparison of datasets with [gplots::heatmap.2()].
#'
#' @param mat numeric matrix, such as produced by [pairwise_emd()] or
#'     [pairwise_mem_rmsd()]. [rotate_matrix_ccw()] can be used to rotate `mat`
#'     as desired. *must* have [dimnames()]!
#' @param pcnt_similarity_scale logical, whether to read `mat` as a distance
#'     matrix and scale its values from 0-100, with 0 for 0 entries in `mat` and
#'     100 for the greatest entry in `mat`, scaled linearly for all others.
#' @param with_dendrograms logical, whether to use dendrograms on the output.
#' @param ... additional arguments to pass to [gplots::heatmap.2()]. These take
#'     precedence over any arguments this function tries to pass.
#'
#' @details `mat` can be any numeric matrix, but this function is specifically
#'     designed for the case when `mat` is a distance matrix (symmetric, all
#'     values nonnegative). `pcnt_similarity_scale = TRUE` creates a
#'     "similarity matrix" from `mat`, scaling its values linearly from 0-100,
#'     using 100 for 0 entries of `mat` and 0 for the greatest entry of `mat`.
#'
#' @seealso [gplots::heatmap.2()] for the underlying plotting
#'     function, and [grDevices::colorRampPalette()] for color palette
#'     generation. [pairwise_emd()] or [pairwise_mem_rmsd()]
#'     should be used to generate `matrix_file`. [rotate_matrix_ccw()] can be
#'     used to rotate the matrix `mat` as desired.
#'
#' @examples
#' mat <- as.matrix(dist(rnorm(5)))
#' ## row/colnames are required for this function
#' dimnames(mat) <- list(c("uno", "dos", "tres", "cuatro", "cinco"),
#'                       c("uno", "dos", "tres", "cuatro", "cinco"))
#' mat
#' ##              uno       dos       tres     cuatro      cinco
#' ## uno    0.0000000 0.3647115 1.14159784 1.05391169 1.17646111
#' ## dos    0.3647115 0.0000000 0.77688632 0.68920017 0.81174959
#' ## tres   1.1415978 0.7768863 0.00000000 0.08768615 0.03486327
#' ## cuatro 1.0539117 0.6892002 0.08768615 0.00000000 0.12254942
#' ## cinco  1.1764611 0.8117496 0.03486327 0.12254942 0.00000000
#'
#' ## no dendrograms, no scaling (default)
#' plot_pairwise_comparison(mat)
#' ## (R graphics device)
#'
#' ## rotated
#' plot_pairwise_comparison(rotate_matrix_ccw(mat))
#' ## (R graphics device)
#'
#' ## add similarity scaling and dendrograms
#' plot_pairwise_comparison(
#'     mat,
#'     pcnt_similarity_scale = TRUE, with_dendrograms = TRUE,
#'     cexRow = 1.5, cexCol = 1.5, margin = c(5, 5))
#' ## (R graphics device)
#'
#' @export
#'
plot_pairwise_comparison <- function (mat,
                                      pcnt_similarity_scale = FALSE,
                                      with_dendrograms = FALSE,
                                      ...) {
    opts <- merge_named_lists(
        list(...),
        list(trace = "none", scale = "none", density.info = "histogram",
             cexRow = .5, cexCol = .5, margin = c(10, 10)))
    if (pcnt_similarity_scale) {
        dims <- dim(mat)
        stopifnot(
            length(dims) == 2,
            dims[1] == dims[2],
            all(mat >= 0))
        ## dist is >= 0 -- this scales it from 0 - 100, where 0 is 0 dist, 100
        ## is max dist of all entries in original matrix
        mat_greatest <- mat %>% max
        mat <- (mat / mat_greatest * 100)
    }
    if (!with_dendrograms) {
        opts <- merge_named_lists(opts, list(
            Rowv = FALSE, Colv = FALSE, dendrogram = "none"))
    }
    map_fun <- get("heatmap.2", asNamespace("gplots"))
    arglist <- c(list(mat), opts)
    do.call(map_fun, arglist)
}
