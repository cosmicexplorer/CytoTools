#' @import magrittr
#' @import dplyr


### Clean fcs data.

extract_pheno_channels <- function (channel_names, pop, pop_desc) {
    ## we're matching channel names by fixed strings, and throw if there are
    ## multiple matches for a channel name. if one channel name is a substring
    ## of another (e.g. CD45RA and CD45), and we search for CD45 first, we'll
    ## find results for both. narrow columns to matches for longer strings first
    longer_first <- channel_names %>% sort %>% rev %T>% {
        stopifnot(anyDuplicated(.) == 0)
    }
    ## FIXME: longer_first should be "super_first", since superstrings that have
    ## different prefixes may still cause errors if the superstring's first
    ## letter is earlier in the alphabet!
    with_canonical_channels <- Reduce(
        x = longer_first,
        init = rep(colnames(pop)),
        f = function (cols, channel) {
            matched <- grep(channel, cols, fixed = TRUE)
            if (length(matched) == 0) {
                stop(sprintf(
                    "no match was found for channel '%s' in population '%s'",
                    channel, pop_desc))
            } else if (length(matched) > 1) {
                stop(sprintf(paste(
                    "more than one match was found for channel '%s'",
                    "in population '%s': [%s]"),
                    channel, pop_desc,
                    paste("\"", cols[matched], "\"",
                          sep = "", collapse = ", ")))
            }
            cols[matched] <- channel
            cols
        })
    with_canonical_channels[,channel_names]
}

## TODO: get alternatives and comparisons to this
#' @title Hyperbolic Arcsin Transform for Cytometry Data
#'
#' @description `asinh_transform` generates a *function* which applies the
#'     hyperbolic transformation with the specified `cofactor`.
#'
#' @param cofactor numeric, divide the input by this number before applying
#'     [asinh()].
#'
#' @return A vectorized *function* accepting one argument `x`, which applies
#'     `asinh(x / cofactor)`.
#'
#' @references Garner, Duane L., et al. "Fluorometric assessments of
#'     mitochondrial function and viability in cryopreserved bovine
#'     spermatozoa." Biology of Reproduction 57.6 (1997): 1401-1406.
#'
#' @seealso The [asinh()] function is used to perform the arcsin transformation.
#'
#' @examples
#' ## create a transformation function
#' arcsin_trans_five <- asinh_transform(5)
#' ## this returns a function!
#' ## function (x) { asinh(x / cofactor) }
#' ## <environment: 0xf6e0da8>
#'
#' ## create some example inputs
#' v <- c(4, 3.2)
#' ## [1] 4.0 3.2
#' m <- matrix((1:4)^1.5, nrow = 2)
#' ##          [,1]     [,2]
#' ## [1,] 1.000000 5.196152
#' ## [2,] 2.828427 8.000000
#'
#' ## use the transformation on your data
#' arcsin_trans_five(v)
#' ## [1] 0.7326683 0.6028207
#' arcsin_trans_five(m)
#' ##           [,1]      [,2]
#' ## [1,] 0.1986901 0.9088435
#' ## [2,] 0.5391786 1.2489833
#'
#' @export
#'
asinh_transform <- function (cofactor) { function (x) {
    asinh(x / cofactor)
}}

#' @title Extract and Transform Phenotype Channels from a CyToF Dataset
#'
#' @description `normalize_pheno_channels_dataset` matches a set of canonical
#'     channel names containing phenotype data over a list of populations and
#'     reference population, and applies a specified transformation to the
#'     phenotype channels.
#'
#' @param pheno_channel_names character vector without duplicates containing
#'     names of channels to extract from each population. See details for how it
#'     is interpreted.
#' @param pop_list list of data frames containing CyToF data as from
#'     [read_files_sorted()].
#' @param ref a data frame containing CyToF data, as from [read_cyto_file()], or
#'     NULL. If NULL, the populations in `pop_list` are joined with [rbind()]
#'     after their channel names are converted to `pheno_channel_names`.
#' @param transform_fun vectorized function to transform the raw channel values,
#'     such as generated by [asinh_transform()].
#'
#' @details ?
#'
#' @return named list with keys `pop_list` and `ref`.
#'
#'     The key `pop_list` contains the list of data frames from the argument
#'     `pop_list` after extracting `pheno_channel_names`. The [names()] of the
#'     argument `pop_list` are reused if the list has them, otherwise the
#'     indices `1:length(pop_list)` are coerced to a character vector and used
#'     as names instead.
#'
#'     The key `ref` contains a data frame with either the reference population
#'     given by the argument `ref` (with the columns matched by
#'     `pheno_channel_names` extracted), or all the events in `pop_list` joined
#'     together with [rbind()] after extracting `pheno_channel_names`.
#'
#' @seealso [read_files_sorted()] and [read_cyto_file()] to use as inputs to
#'     `pop_list` and `ref`, and [asinh_transform()] to use as a transformation
#'     on the raw channel values.
#'
#' @export
#'
normalize_pheno_channels_dataset <- function
(
    pheno_channel_names, pop_list,
    ref = NULL,
    transform_fun = asinh_transform(5)
) {
    stopifnot(is.vector(pheno_channel_names, 'character'),
              is.list(pop_list),
              lapply(pop_list, is.data.frame) %>% unlist,
              (is.null(ref) || is.data.frame(ref)),
              is.function(transform_fun))
    pop_names <- names(pop_list) %>% {
        if (!is.null(.)) { . } else { as.character(1:length(pop_list)) }
    }
    pops_correct_channels <- lapply(1:length(pop_names), function (i) {
        extract_pheno_channels(pheno_channel_names,
                               pop_list[[i]], pop_names[[i]]) %>%
            as.matrix %>%
            transform_fun
    })
    ref_correct_channels <- if (!is.null(ref)) {
                                extract_pheno_channels(pheno_channel_names,
                                                       ref, "REF") %>%
                                    as.matrix %>%
                                    transform_fun
                            } else {
                                Reduce(x = pops_correct_channels, f = rbind)
                            }
    list(pop_list = pops_correct_channels,
         ref = ref_correct_channels)
}


### Analyze populations in a dataset.

compute_pairwise_emd_trials <- function (matrices, clust,
                                         downsample_rows, comparison_runs,
                                         verbose_timing) {
    n <- length(matrices)
    msg("starting pairwise emd on %s populations...", n)
    lapply(1:n, function (i) {
        final_col <- as.integer(n - i)
        msg("computing row %s/%s, requiring column(s) %s:%s",
            i, n, 1, final_col)
        i_mat <- matrices[[i]]
        cols <- safe_int_seq(1L, final_col)
        parallel::parLapply(clust, cols, function (j) {
            this_pid <- Sys.getpid()
            j_mat <- matrices[[n - j + 1]]
            lapply(1:comparison_runs, function (r) {
                i_wpp <- sample(1:nrow(i_mat), downsample_rows) %>%
                    i_mat[.,] %>% transport::wpp(rep(1, downsample_rows))
                j_wpp <- sample(1:nrow(j_mat), downsample_rows) %>%
                    j_mat[.,] %>% transport::wpp(rep(1, downsample_rows))
                single_entry <- CytoTools::timed_execute(transport::wasserstein(
                    i_wpp, j_wpp, control = transport::trcontrol(
                        a = i_wpp, b = j_wpp, method = "shortsimplex")),
                    ## weird that this is necessary when using timed_execute
                    ## inside a worker
                    env = environment())
                if (verbose_timing) {
                    message(sprintf(paste(
                        "run %s/%s for row %s/%s, column %s/%s",
                        "on worker %s took %s sec"),
                        r, comparison_runs, i, n, j, length(cols),
                        this_pid, single_entry$time))
                }
                single_entry$value
            }) %>% unlist
        })
    })
}

summarize_computed_trials <- function (fun, trials, nm) {
    stopifnot(is.function(fun))
    n <- length(trials)
    result <- matrix(double(n * n), n, n, dimnames = list(nm, rev(nm)))
    for (i in 1:n) {
        next_cols <- result[rev(safe_int_seq(1L, as.integer(i - 1))),
                            (n - i + 1)]
        result[i,] <- lapply(trials[[i]], fun) %>% unlist %>% c(0, next_cols)
    }
    result
}


#' @title Compute Pairwise EMD Over a List of Matrices
#'
#' @description `pairwise_emd` computes the Earth Mover's Distance (EMD)
#'     between the rows of each pair of matrices given, and writes the
#'     resultant distance matrix to a CSV file.
#'
#' @param tsne_matrices named list of matrices, each with the same number of
#'     columns. Need not have the same number of rows, but should be nonempty.
#' @param downsample_rows positive integer, the number of rows to downsample
#'     each matrix to on each EMD comparison. If this is greater than the number
#'     of rows in the matrix with fewest rows in `tsne_matrices`, it will be
#'     shrunk to the number of rows of the smallest matrix.
#' @param comparison_runs positive integer, the number of times to perform the
#'     EMD computation for each pair of matrices in `tsne_matrices`.
#' @param summary_funs list of functions, each of which accept a floating-point
#'     vector and produce a scalar floating-point. Names will be reused in the
#'     output if provided.
#' @param parallel_cores positive integer, number of cores to use for
#'     parallelism. Default should be optimal.
#' @param verbose_timing logical, whether to display a message describing the
#'     runtime at the conclusion of each EMD calculation.
#'
#' @return Named list of symmetric distance matrices containing the result of
#'     applying each of `summary_funs` to each vector of `comparison_runs` EMD
#'     calculations for each pair of matrices in the input. Each matrix's row
#'     and column names are set to the names of `tsne_matrices`.
#'
#'     The output list also contains the keys `downsample_rows` and
#'     `comparison_runs` (in that order, at the start of the output list),
#'     containing the values provided to these arguments when this function was
#'     called. If names are provided to elements of `summary_funs`, they are
#'     reused for the corresponding element of the output list.
#'
#' @details For each pair of matrices in `tsne_matrices`, a floating-point
#'     vector is generated by downsampling both matrices to
#'     `downsample_rows` and performing the EMD calculation on the downsampled
#'     matrices with [transport::wasserstein()]. This is performed
#'     `comparison_runs` times per pair of matrices, producing a vector of
#'     length `comparison_runs`.
#'
#'     Each function in `summary_funs` is applied to each vector of EMD
#'     calculations, producing a list of symmetrical distance matrices. In other
#'     words, each of the matrices in this list is produced by applying the
#'     corresponding function in `summary_funs` to the vector of EMD
#'     calculations for each pair of elements in `tsne_matrices`. If names are
#'     provided to elements of `summary_funs`, they are reused for the
#'     corresponding element of the output list.
#'
#'     For example, if `summary_funs = list(mean = mean)`, the output list
#'     contains an n x n matrix of the mean of each EMD run for each pair of
#'     matrices in `tsne_matrices` (where `n == length(tsne_matrices)`).
#'
#' @seealso [transport::wasserstein()] for the underlying EMD
#'     implementation. [gplots::heatmap.2()] can be used to plot heatmaps of the
#'     distance matrices computed.
#'
#' @examples
#' ## create example matrices (need not have same number of rows)
#' a <- matrix(runif(100, 0, 1), ncol = 2)
#' b <- matrix(runif(100, 0, 1), ncol = 2)
#' c <- matrix(runif(100, 0, 1), ncol = 2)
#' ## calc pairwise EMD 15 times and get mean, median, and sample variance of
#' ## the 15 calculations per pair, downsampling to 45 rows each time
#' result <- pairwise_emd(
#'     list("matrix A" = a,
#'          "matrix B" = b,
#'          "matrix C" = c),
#'     downsample_rows = 45,
#'     comparison_runs = 15,
#'     summary_funs = list("mean" = mean,
#'                         "median" = median,
#'                         "variance" = var))
#' ## the downsampling size/sample runs specified are also in the output;
#' ## also observe that the distance matrices are symmetric along the diagonal
#' ## from the lower-left to upper-right
#' result
#' ## $downsample_rows
#' ## [1] 45
#' ##
#' ## $comparison_runs
#' ## [1] 15
#' ##
#' ## $mean
#' ##           matrix C  matrix B  matrix A
#' ## matrix A 0.1342866 0.1524013 0.0000000
#' ## matrix B 0.1094125 0.0000000 0.1524013
#' ## matrix C 0.0000000 0.1094125 0.1342866
#' ##
#' ## $median
#' ##           matrix C  matrix B  matrix A
#' ## matrix A 0.1351538 0.1556969 0.0000000
#' ## matrix B 0.1101228 0.0000000 0.1556969
#' ## matrix C 0.0000000 0.1101228 0.1351538
#' ##
#' ## $variance
#' ##              matrix C     matrix B     matrix A
#' ## matrix A 0.0001382563 0.0001742527 0.0000000000
#' ## matrix B 0.0000721925 0.0000000000 0.0001742527
#' ## matrix C 0.0000000000 0.0000721925 0.0001382563
#' ## plot a heatmap of the mean EMD
#' gplots::heatmap.2(result$mean, cexRow = 1, cexCol = 1)
#' ## (R graphics window)
#'
#' @export
#'
pairwise_emd <- function
(
    tsne_matrices,
    downsample_rows = 1000,
    comparison_runs = 10,
    summary_funs = list(mean = mean, variance = var),
    parallel_cores = parallel::detectCores(),
    verbose_timing = FALSE
) {
    downsample_rows <- tsne_matrices %>% lapply(nrow) %>% unlist %>%
        min(downsample_rows) %>% as.integer
    comparison_runs <- as.integer(comparison_runs)
    stopifnot(is_counting_num(downsample_rows),
              is_counting_num(comparison_runs),
              is_counting_num(parallel_cores))
    nm <- get_names(tsne_matrices)
    ## NOTE: outfile = "" goes to console, EXCEPT in Rgui on Windows!
    clust <- parallel::makeCluster(parallel_cores, outfile = "")
    computed_trials <- tryCatch(
        finally = parallel::stopCluster(clust),
        compute_pairwise_emd_trials(
            tsne_matrices, clust, downsample_rows, comparison_runs,
            verbose_timing))
    c(list(downsample_rows = downsample_rows,
           comparison_runs = comparison_runs),
      lapply(summary_funs, (. %>% summarize_computed_trials(
          computed_trials, nm))))
}

normal_iqr <- function (x, ...) {
    IQR(x, type = 2, ...)
}

#' @title Compute MEM Scores Over Populations in a Dataset
#'
#' @description `calc_mem` computes the Marker Enrichment Modelling (MEM) score
#'     of each population given against the provided reference population.
#'
#' @param pop_list list of floating-point matrices, each with the same column
#'     names in the same order. Each column represents *transformed* expression
#'     levels of the named phenotype.
#' @param ref floating-point matrix with the same column names in the same order
#'     as each element of `pop_list`, with entries representing *transformed*
#'     expression levels. Used as reference population.
#' @param IQRthresh positive scalar floating-point, used as lower bound for IQR
#'     calculations (see MEM paper).
#' @param scale_limit positive scalar floating-point or `NULL`. If not `NULL`,
#'     MEM values are scaled so the greatest maximum absolute MEM value is equal
#'     to `scale_limit`, otherwise no scaling occurs.
#'
#' @return matrix with column names as in `pop_list` and `ref`, row names equal
#'     to the names of `pop_list` (if given). Each row contains the MEM values
#'     of a population in `pop_list` for each phenotype channel, in the same
#'     order as given.
#'
#' @details Note that the values of entries in `ref` and the populations of
#'     `pop_list` are assumed to already be transformed (typically an arcsinh
#'     transform, as in [asinh_transform()]).
#'
#' @seealso [normalize_pheno_channels_dataset()] can be used to generate
#'     a suitable `pop_list` and `ref` from a CyToF dataset, applying
#'     transformations and normalizing phenotype channel names.
#'
#' @references Diggins, Kirsten E., et al. "Characterizing cell subsets using
#'     marker enrichment modeling." Nature Methods 14.3 (2017): 275-278.
#'
#' @export
#'
calc_mem <- function (pop_list, ref,
                      IQRthresh = 0.5,
                      scale_limit = NULL) {
    markers <- colnames(ref)
    for (pop in pop_list) {
        stopifnot(compare_names(colnames(pop), markers))
    }
    pop_names <- names(pop_list)
    ## make data frames of pop median/iqr
    mag_pops <- pop_list %>%
        lapply((. %>% apply(2, median))) %>%
        Reduce(f = cbind) %>%
        t %>% set_rownames(pop_names)
    iqr_pops <- pop_list %>%
        lapply((. %>% apply(2, normal_iqr))) %>%
        Reduce(f = cbind) %>%
        t %>% set_rownames(pop_names)
    ## vectors for ref stats
    MAGref <- ref %>% apply(2, median) %>% t
    IQRref <- ref %>% apply(2, normal_iqr) %>% t
    ## FIXME: current MEM function takes abs of MAGpop and MAGref (WHY???)
    mag_diffs <- mag_pops %>%
        apply(1, function (MAGpop) abs(MAGpop) - abs(MAGref)) %>%
        t %>% set_colnames(markers)
    ## FIXME: current MEM function thresholds IQRref as well (WHY???)
    stopifnot(is_nonneg_scalar(IQRthresh, allow_zero = FALSE))
    iqr_ratios_with_threshold <- pmax(iqr_pops, IQRthresh) %>%
        apply(1, function (IQRpop) pmax(IQRref, IQRthresh) / IQRpop) %>%
        t %>% set_colnames(markers)
    ## this is the MEM formula -- see reference
    mems <- (abs(mag_diffs) + iqr_ratios_with_threshold - 1) * sign(mag_diffs)
    ## dilate so the greatest MEM value has magnitude equal to scale_limit
    if (is.null(scale_limit)) {
        mems
    } else {
        stopifnot(is_nonneg_scalar(scale_limit, allow_zero = FALSE))
        max_mem <- mems %>% abs %>% max
        mems / max_mem * scale_limit
    }
}


#' @title Plot Pairwise Comparisons of Cytometry Datasets
#'
#' @description `plot_pairwise_comparison` plots a heatmap of a pairwise
#'     comparison of datasets with [gplots::heatmap.2()].
#'
#' @param mat A comparison matrix produced by [pairwise_emd()] or
#'     [pairwise_mem_rmsd()].
#' @param pcnt_similarity_scale ?
#' @param with_dendrograms ?
#' @param ... ?
#'
#' @seealso [gplots::heatmap.2()] for the underlying plotting
#'     function, and [grDevices::colorRampPalette()] for color palette
#'     generation. [pairwise_emd()] or [pairwise_mem_rmsd()]
#'     should be used to generate `matrix_file`.
#'
#' @export
#'
plot_pairwise_comparison <- function (mat,
                                      pcnt_similarity_scale = TRUE,
                                      with_dendrograms = FALSE,
                                      ...) {
    opts <- merge_named_lists(
        list(...),
        list(trace = "none", scale = "none", density.info = "histogram",
             cexRow = .5, cexCol = .5, margin = c(10, 10)))
    if (pcnt_similarity_scale) {
        dims <- dim(mat)
        stopifnot(
            length(dims) == 2,
            dims[1] == dims[2],
            all(mat >= 0))
        ## dist is >= 0 -- this scales it from 0 - 100, where 0 is max dist, 100
        ## is 0 dist
        mat_greatest <- mat %>% max
        mat <- 100 - (mat / mat_greatest * 100)
    }
    if (!with_dendrograms) {
        opts <- merge_named_lists(opts, list(
            Rowv = FALSE, Colv = FALSE, dendrogram = "none"))
    }
    map_fun <- get("heatmap.2", asNamespace("gplots"))
    arglist <- c(list(mat), opts)
    do.call(map_fun, arglist)
}
